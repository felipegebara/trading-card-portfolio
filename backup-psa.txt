import { Component, OnInit, signal, computed, effect, ViewChild, ElementRef, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { supabase } from '../../supabaseClient';
import { PortfolioService } from '../../services/portfolio.service';
import { Subscription } from 'rxjs';

declare const d3: any;

interface ConversionFactors {
  idioma: Map<string, number>;
  estado: Map<string, number>;
}

interface PortfolioPosition {
  carta: string;
  quantidade: number;
  idioma: string;
  estado: string;
  data_compra: string;
}

interface DailyValue {
  date: Date;
  value: number;
  breakdown: { carta: string; value: number }[];
}

@Component({
  selector: 'app-portfolio-consolidated',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
    <!-- ... (template remains unchanged) ... -->
    <div class="consolidated-container">
      <div class="header">
        <div class="header-content">
          <div>
            <h2 class="title">üíº Performance Consolidada do Portf√≥lio</h2>
            <p class="subtitle">Valor total de todas as suas cartas ao longo do tempo</p>
          </div>
          <button class="refresh-btn" (click)="refresh()" [disabled]="loading()" title="Atualizar dados">
            <span class="refresh-icon" [class.spinning]="loading()">‚Üª</span>
          </button>
        </div>
      </div>

      <!-- Period Filter -->
      <div class="filter-row">
        <div class="filter-group">
          <label>PER√çODO</label>
          <select [ngModel]="selectedPeriod()" (ngModelChange)="selectedPeriod.set($event)" class="filter-select">
            <option value="7">7 dias</option>
            <option value="30">30 dias</option>
            <option value="90">90 dias</option>
            <option value="180">6 meses</option>
            <option value="365">1 ano</option>
            <option value="ALL">Todo per√≠odo</option>
          </select>
        </div>
      </div>

      <!-- KPIs -->
      <div class="kpis-row" *ngIf="!loading() && kpis()">
        <div class="kpi-card highlight">
          <div class="kpi-icon">üí∞</div>
          <div class="kpi-content">
            <p class="kpi-label">VALOR ATUAL</p>
            <p class="kpi-value">R$ {{ kpis().currentValue | number:'1.2-2' }}</p>
          </div>
        </div>

        <div class="kpi-card" [class.positive]="kpis().percentChange >= 0" [class.negative]="kpis().percentChange < 0">
          <div class="kpi-icon">{{ kpis().percentChange >= 0 ? 'üìà' : 'üìâ' }}</div>
          <div class="kpi-content">
            <p class="kpi-label">VARIA√á√ÉO NO PER√çODO</p>
            <p class="kpi-value" [class.positive]="kpis().percentChange >= 0" [class.negative]="kpis().percentChange < 0">
              {{ kpis().percentChange >= 0 ? '+' : '' }}{{ kpis().percentChange | number:'1.2-2' }}%
            </p>
            <p class="kpi-sub" [class.positive]="kpis().valueChange >= 0" [class.negative]="kpis().valueChange < 0">
              {{ kpis().valueChange >= 0 ? '+' : '' }}R$ {{ kpis().valueChange | number:'1.2-2' }}
            </p>
          </div>
        </div>

        <div class="kpi-card">
          <div class="kpi-icon">üöÄ</div>
          <div class="kpi-content">
            <p class="kpi-label">MAIOR VALOR</p>
            <p class="kpi-value">R$ {{ kpis().maxValue | number:'1.2-2' }}</p>
            <p class="kpi-sub">Alcan√ßado em {{ formatDate(kpis().maxDate) }}</p>
          </div>
        </div>

        <div class="kpi-card">
          <div class="kpi-icon">‚¨áÔ∏è</div>
          <div class="kpi-content">
            <p class="kpi-label">MENOR VALOR</p>
            <p class="kpi-value">R$ {{ kpis().minValue | number:'1.2-2' }}</p>
            <p class="kpi-sub">Registrado em {{ formatDate(kpis().minDate) }}</p>
          </div>
        </div>
      </div>

      <!-- Chart -->
      <div class="chart-wrapper">
        <div *ngIf="loading()" class="loading-state">
          <div class="spinner"></div>
          <p>Calculando valor do portf√≥lio...</p>
        </div>
        
        <div *ngIf="!loading() && chartData().length === 0" class="empty-state">
          <p>Adicione cartas ao seu portf√≥lio para ver a performance</p>
        </div>

        <div #chartContainer class="chart-container" [class.hidden]="loading() || chartData().length === 0"></div>
      </div>
    </div>
  `,
  styles: [`
    /* ... (styles remain unchanged) ... */
    .consolidated-container {
      background: rgba(255, 255, 255, 0.85);
      border: 2px solid rgba(255, 193, 204, 0.3);
      border-radius: 16px;
      padding: 24px;
      color: #1f2937;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
    }

    .header { margin-bottom: 24px; }
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    .title { font-size: 22px; font-weight: 700; color: #cc9f00; margin: 0 0 4px 0; }
    .subtitle { font-size: 14px; color: #6b7280; margin: 0; }

    .refresh-btn {
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(255, 193, 204, 0.5);
      border-radius: 8px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      color: #cc9f00;
      font-size: 18px;
    }
    .refresh-btn:hover:not(:disabled) {
      background: #fff;
      border-color: #ffc700;
      color: #ffc700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .refresh-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .refresh-icon { display: inline-block; }
    .refresh-icon.spinning { animation: spin 1s linear infinite; }

    .filter-row {
      display: flex;
      gap: 16px;
      margin-bottom: 24px;
    }

    .filter-group { display: flex; flex-direction: column; gap: 8px; min-width: 150px; }
    .filter-group label { font-size: 11px; font-weight: 700; color: #9ca3af; text-transform: uppercase; letter-spacing: 1px; }
    
    .filter-select {
      background: #fef8e8;
      border: 2px solid rgba(255, 193, 204, 0.3);
      border-radius: 8px;
      padding: 10px 12px;
      color: #1f2937;
      font-size: 14px;
      outline: none;
      transition: all 0.2s;
    }
    .filter-select:focus { 
      border-color: #ffc700; 
      box-shadow: 0 0 0 3px rgba(255, 199, 0, 0.1); 
    }

    .kpis-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .kpi-card {
      background: rgba(254, 248, 232, 0.6);
      border: 2px solid rgba(168, 216, 234, 0.3);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 16px;
      transition: all 0.2s;
    }

    .kpi-card.highlight { 
      background: linear-gradient(135deg, rgba(255, 199, 0, 0.15) 0%, rgba(255, 193, 204, 0.15) 100%);
      border-color: rgba(255, 199, 0, 0.4); 
      box-shadow: 0 4px 6px -1px rgba(255, 199, 0, 0.1);
    }
    .kpi-card.positive { 
      background: rgba(188, 233, 197, 0.2); 
      border-color: rgba(188, 233, 197, 0.5); 
    }
    .kpi-card.negative { 
      background: rgba(255, 107, 107, 0.1); 
      border-color: rgba(255, 107, 107, 0.3); 
    }
    
    .kpi-icon { font-size: 28px; }
    .kpi-content { flex: 1; }
    .kpi-label { font-size: 11px; color: #6b7280; margin: 0 0 4px 0; font-weight: 700; }
    .kpi-value { font-size: 20px; font-weight: 700; color: #1f2937; margin: 0; }
    .kpi-value.positive { color: #059669; }
    .kpi-value.negative { color: #ff6b6b; }
    .kpi-sub { font-size: 12px; color: #6b7280; margin: 4px 0 0 0; }
    .kpi-sub.positive { color: #059669; }
    .kpi-sub.negative { color: #ff6b6b; }

    .chart-wrapper {
      background: linear-gradient(135deg, #fef8e8 0%, rgba(255, 255, 255, 0.9) 100%);
      border-radius: 12px;
      border: 2px solid rgba(168, 216, 234, 0.3);
      height: 450px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .chart-container { width: 100%; height: 100%; }
    .hidden { display: none; }

    .loading-state, .empty-state {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 193, 204, 0.3);
      border-top-color: #ffc700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    ::ng-deep .chart-tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.98);
      border: 2px solid rgba(255, 193, 204, 0.5);
      border-radius: 8px;
      padding: 12px;
      color: #1f2937;
      font-size: 12px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 100;
      backdrop-filter: blur(8px);
      min-width: 200px;
    }
  `]
})
export class PortfolioConsolidatedComponent implements OnInit, OnDestroy {
  @ViewChild('chartContainer') chartContainer!: ElementRef;

  // Signals
  selectedPeriod = signal<string>('30');
  loading = signal(false);
  chartData = signal<DailyValue[]>([]);
  conversionFactors = signal<ConversionFactors>({ idioma: new Map(), estado: new Map() });

  private refreshSubscription: Subscription;

  // Computed KPIs
  kpis = computed(() => {
    const data = this.chartData();
    if (data.length === 0) return null;

    const currentValue = data[data.length - 1].value;
    const startValue = data[0].value;
    const percentChange = ((currentValue - startValue) / startValue) * 100;
    const valueChange = currentValue - startValue;

    // Find max and min with dates
    const maxEntry = data.reduce((max, d) => d.value > max.value ? d : max, data[0]);
    const minEntry = data.reduce((min, d) => d.value < min.value ? d : min, data[0]);

    return {
      currentValue,
      percentChange,
      valueChange,
      maxValue: maxEntry.value,
      maxDate: maxEntry.date,
      minValue: minEntry.value,
      minDate: minEntry.date
    };
  });

  constructor(private portfolioService: PortfolioService) {
    effect(() => {
      const period = this.selectedPeriod();
      this.loadConsolidatedData(period);
    });

    effect(() => {
      const data = this.chartData();
      if (data.length > 0 && this.chartContainer) {
        setTimeout(() => this.drawChart(), 0);
      }
    });

    this.refreshSubscription = this.portfolioService.refresh$.subscribe(() => {
      console.log('üîÑ [Consolidated] Refreshing data due to portfolio update...');
      this.loadConsolidatedData(this.selectedPeriod());
    });
  }

  ngOnDestroy() {
    if (this.refreshSubscription) {
      this.refreshSubscription.unsubscribe();
    }
  }

  refresh() {
    console.log('üîÑ [Consolidated] Refresh manual solicitado');
    this.loadConsolidatedData(this.selectedPeriod());
  }

  formatDate(date: Date): string {
    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
  }

  async ngOnInit() {
    await this.loadConversionFactors();
  }

  async loadConversionFactors() {
    console.log('üìä [Consolidated] Usando fatores de convers√£o hardcoded...');

    // Hardcoded factors as requested
    const idiomaMap = new Map([
      ['PT-BR', 1.0],
      ['EN', 0.85],
      ['JPN', 1.15],
      ['ES', 0.90],
      ['FR', 0.88],
      ['DE', 0.87],
      ['IT', 0.86]
    ]);

    const estadoMap = new Map([
      ['NM', 1.0],
      ['SP', 0.7],
      ['MP', 0.5],
      ['HP', 0.3],
      ['D', 0.1]
    ]);

    this.conversionFactors.set({ idioma: idiomaMap, estado: estadoMap });

    console.log('‚úÖ [Consolidated] Fatores carregados (Hardcoded):', {
      idioma: Array.from(idiomaMap.entries()),
      estado: Array.from(estadoMap.entries())
    });
  }

  async loadConsolidatedData(period: string) {
    this.loading.set(true);
    try {
      // 1. Get all user positions
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        this.loading.set(false);
        return;
      }

      const { data: positions, error: posError } = await supabase
        .from('portfolio_cards')
        .select('carta, qtd, idioma, estado, data_compra')
        .eq('user_id', user.id);

      if (posError) throw posError;
      if (!positions || positions.length === 0) {
        this.chartData.set([]);
        this.loading.set(false);
        return;
      }

      console.log(`üìä Loading data for ${positions.length} positions`);

      // 2. Calculate date range
      const endDate = new Date();
      let startDate = new Date();

      if (period !== 'ALL') {
        startDate.setDate(endDate.getDate() - parseInt(period));
      } else {
        // Get earliest purchase date
        const earliestPurchase = positions.reduce((min, p) => {
          const pDate = new Date(p.data_compra);
          return pDate < min ? pDate : min;
        }, new Date());
        startDate = earliestPurchase;
      }

      // 3. For each position, get price history
      const dailyValues = new Map<string, number>();
      const factors = this.conversionFactors();

      for (const position of positions) {
        const priceHistory = await this.getPriceHistory(
          position.carta,
          startDate.toISOString().split('T')[0],
          endDate.toISOString().split('T')[0]
        );

        // Deduplicate price history by date (keep the last entry for each day)
        const uniqueDailyPrices = new Map<string, any>();
        priceHistory.forEach((priceData) => {
          const dateKey = priceData.data_coleta.split('T')[0];
          uniqueDailyPrices.set(dateKey, priceData);
        });

        // For each unique date, calculate value
        uniqueDailyPrices.forEach((priceData, dateKey) => {
          const adjustedPrice = this.getAdjustedPrice(
            priceData,
            position.idioma,
            position.estado,
            factors
          );

          const positionValue = position.qtd * adjustedPrice;
          dailyValues.set(dateKey, (dailyValues.get(dateKey) || 0) + positionValue);
        });
      }

      // 4. Convert to array and sort
      const consolidated: DailyValue[] = Array.from(dailyValues.entries())
        .map(([dateStr, value]) => ({
          date: new Date(dateStr),
          value,
          breakdown: [] // TODO: Add card breakdown if needed
        }))
        .sort((a, b) => a.date.getTime() - b.date.getTime());

      console.log(`‚úÖ Consolidated ${consolidated.length} daily values`);
      this.chartData.set(consolidated);

    } catch (e) {
      console.error('‚ùå Error loading consolidated data:', e);
      this.chartData.set([]);
    } finally {
      this.loading.set(false);
    }
  }

  async getPriceHistory(carta: string, startDate: string, endDate: string) {
    const cleanName = carta.trim();
    console.log(`üìä [Chart] Buscando hist√≥rico para: "${cleanName}"`);

    try {
      // 1. Tentativa Exata
      let { data, error } = await supabase
        .from('myp_cards_meg')
        .select('data_coleta, preco_minimo_carta, idioma, estado, carta')
        .eq('carta', cleanName)
        .gte('data_coleta', startDate)
        .lte('data_coleta', endDate)
        .order('data_coleta', { ascending: true });

      if (data && data.length > 0) {
        console.log(`‚úÖ [Chart] Hist√≥rico EXATO encontrado: ${data.length} pontos`);
        return data;
      }

      console.warn(`‚ö†Ô∏è [Chart] Hist√≥rico exato vazio para "${cleanName}". Tentando ILIKE...`);

      // 2. Tentativa Case Insensitive
      const { data: ilikeData } = await supabase
        .from('myp_cards_meg')
        .select('data_coleta, preco_minimo_carta, idioma, estado, carta')
        .ilike('carta', cleanName)
        .gte('data_coleta', startDate)
        .lte('data_coleta', endDate)
        .order('data_coleta', { ascending: true });

      if (ilikeData && ilikeData.length > 0) {
        console.log(`‚úÖ [Chart] Hist√≥rico ILIKE encontrado: ${ilikeData.length} pontos`);
        return ilikeData;
      }

      console.warn(`‚ö†Ô∏è [Chart] Hist√≥rico ILIKE vazio. Tentando parcial...`);

      // 3. Tentativa Parcial (primeiros 15 chars) - MAS FILTRA PARA UMA √öNICA CARTA
      const partialName = cleanName.substring(0, 15) + '%';
      const { data: partialData } = await supabase
        .from('myp_cards_meg')
        .select('data_coleta, preco_minimo_carta, idioma, estado, carta')
        .ilike('carta', partialName)
        .gte('data_coleta', startDate)
        .lte('data_coleta', endDate)
        .order('data_coleta', { ascending: true });

      if (partialData && partialData.length > 0) {
        // ‚ö†Ô∏è CR√çTICO: A busca parcial pode retornar M√öLTIPLAS cartas!
        // Precisamos filtrar para pegar apenas UMA carta espec√≠fica
        const uniqueCards = new Set(partialData.map(p => p.carta));

        if (uniqueCards.size > 1) {
          console.warn(`‚ö†Ô∏è [Chart] Busca parcial retornou ${uniqueCards.size} cartas diferentes. Usando apenas a primeira: "${Array.from(uniqueCards)[0]}"`);
          // Pega apenas os dados da primeira carta encontrada
          const firstCard = Array.from(uniqueCards)[0];
          const filteredData = partialData.filter(p => p.carta === firstCard);
          console.log(`‚úÖ [Chart] Hist√≥rico PARCIAL filtrado: ${filteredData.length} pontos para "${firstCard}"`);
          return filteredData;
        } else {
          console.log(`‚úÖ [Chart] Hist√≥rico PARCIAL encontrado: ${partialData.length} pontos para "${partialData[0].carta}"`);
          return partialData;
        }
      }

      console.error(`‚ùå [Chart] NENHUM hist√≥rico encontrado para "${cleanName}"`);
      return [];

    } catch (e) {
      console.error(`‚ùå [Chart] Erro ao buscar hist√≥rico para ${carta}:`, e);
      return [];
    }
  }

  getAdjustedPrice(priceData: any, targetIdioma: string, targetEstado: string, factors: ConversionFactors): number {
    const basePrice = parseFloat(priceData.preco_minimo_carta);

    // Check if exact match
    if (priceData.idioma === targetIdioma && priceData.estado === targetEstado) {
      return basePrice;
    }

    // Apply conversion factors
    let adjustedPrice = basePrice;

    const sourceIdiomaFactor = factors.idioma.get(priceData.idioma) || 1.0;
    const targetIdiomaFactor = factors.idioma.get(targetIdioma) || 1.0;
    adjustedPrice *= (targetIdiomaFactor / sourceIdiomaFactor);

    const sourceEstadoFactor = factors.estado.get(priceData.estado) || 1.0;
    const targetEstadoFactor = factors.estado.get(targetEstado) || 1.0;
    adjustedPrice *= (targetEstadoFactor / sourceEstadoFactor);

    return adjustedPrice;
  }

  drawChart() {
    const element = this.chartContainer.nativeElement;
    const data = this.chartData();

    d3.select(element).selectAll('*').remove();

    const margin = { top: 20, right: 30, bottom: 40, left: 70 };
    const width = element.offsetWidth - margin.left - margin.right;
    const height = element.offsetHeight - margin.top - margin.bottom;

    const svg = d3.select(element)
      .append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', `0 0 ${element.offsetWidth} ${element.offsetHeight}`)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    const x = d3.scaleTime()
      .domain(d3.extent(data, (d: any) => d.date))
      .range([0, width]);

    const yMin = d3.min(data, (d: any) => d.value);
    const yMax = d3.max(data, (d: any) => d.value);
    const yPadding = (yMax - yMin) * 0.1;

    const y = d3.scaleLinear()
      .domain([yMin - yPadding, yMax + yPadding])
      .range([height, 0]);

    // Grid
    svg.append('g')
      .attr('class', 'grid')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x).ticks(6).tickSize(-height).tickFormat(''))
      .style('stroke', 'rgba(255, 193, 204, 0.2)')
      .style('stroke-dasharray', '3,3');

    svg.append('g')
      .attr('class', 'grid')
      .call(d3.axisLeft(y).ticks(6).tickSize(-width).tickFormat(''))
      .style('stroke', 'rgba(255, 193, 204, 0.2)')
      .style('stroke-dasharray', '3,3');

    // Axes
    svg.append('g')
      .attr('transform', `translate(0, ${height})`)
      .call(d3.axisBottom(x).ticks(6).tickFormat(d3.timeFormat('%d/%m')))
      .style('color', '#9ca3af');

    svg.append('g')
      .call(d3.axisLeft(y).ticks(6).tickFormat((d: number) => `R$ ${d3.format(',.0f')(d)} `))
      .style('color', '#9ca3af');

    // Gradient
    const gradient = svg.append('defs')
      .append('linearGradient')
      .attr('id', 'area-gradient-consolidated')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '0%')
      .attr('y2', '100%');

    gradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#ffc700')
      .attr('stop-opacity', 0.3);

    gradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#ffc700')
      .attr('stop-opacity', 0);

    // Area
    const area = d3.area()
      .x((d: any) => x(d.date))
      .y0(height)
      .y1((d: any) => y(d.value))
      .curve(d3.curveMonotoneX);

    svg.append('path')
      .datum(data)
      .attr('fill', 'url(#area-gradient-consolidated)')
      .attr('d', area);

    // Line
    const line = d3.line()
      .x((d: any) => x(d.date))
      .y((d: any) => y(d.value))
      .curve(d3.curveMonotoneX);

    const path = svg.append('path')
      .datum(data)
      .attr('fill', 'none')
      .attr('stroke', '#ffc700')
      .attr('stroke-width', 3)
      .attr('d', line);

    // Animate
    const totalLength = path.node().getTotalLength();
    path
      .attr('stroke-dasharray', totalLength + ' ' + totalLength)
      .attr('stroke-dashoffset', totalLength)
      .transition()
      .duration(1500)
      .ease(d3.easeCubicOut)
      .attr('stroke-dashoffset', 0);

    // Tooltip
    const tooltip = d3.select(element)
      .append('div')
      .attr('class', 'chart-tooltip')
      .style('opacity', 0);

    const overlay = svg.append('rect')
      .attr('width', width)
      .attr('height', height)
      .style('fill', 'none')
      .style('pointer-events', 'all');

    const bisect = d3.bisector((d: any) => d.date).left;

    const focus = svg.append('g')
      .append('circle')
      .style('fill', '#ffc700')
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .attr('r', 6)
      .style('opacity', 0);

    overlay.on('mousemove', (event: any) => {
      const x0 = x.invert(d3.pointer(event)[0]);
      const i = bisect(data, x0, 1);
      const d0 = data[i - 1];
      const d1 = data[i];
      const d = x0.getTime() - d0.date.getTime() > d1.date.getTime() - x0.getTime() ? d1 : d0;

      focus
        .attr('cx', x(d.date))
        .attr('cy', y(d.value))
        .style('opacity', 1);

      tooltip
        .transition()
      tooltip.transition().duration(200).style('opacity', 0);
    });
  }
}
